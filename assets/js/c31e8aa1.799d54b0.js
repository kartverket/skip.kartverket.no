"use strict";(self.webpackChunkskip_docs=self.webpackChunkskip_docs||[]).push([[756],{74474:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var a=n(80482),i=n(74848),s=n(28453);const o={title:"Scaling with Argo CD: Introducing the Apps Repo Architecture",description:"What's the best way to scale when adding more teams to Argo CD? How can we make sure that we're building our GitOps in a way that facilitates self service and security? Kartverket shares our experiences and introduces the apps repo architecture\n",slug:"introducing-apps-repositories",authors:["elinehenriksen"],tags:["kubernetes","argo-cd","gitops"],image:"/img/apps-repo-announcment.jpeg",hide_table_of_contents:!1},r=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Multi-tenancy in Argo CD",id:"multi-tenancy-in-argo-cd",level:2},{value:"What are ApplicationSets?",id:"what-are-applicationsets",level:2},{value:"Introducing apps repositories",id:"introducing-apps-repositories",level:2},{value:"Automating and avoiding duplication",id:"automating-and-avoiding-duplication",level:2},{value:"Security considerations",id:"security-considerations",level:2},{value:"Prefixes",id:"prefixes",level:3},{value:"Namespace resources",id:"namespace-resources",level:3},{value:"Self service customization",id:"self-service-customization",level:2},{value:"Example ApplicationSet",id:"example-applicationset",level:3},{value:"Complete ApplicationSet",id:"complete-applicationset",level:2},{value:"Results",id:"results",level:2},{value:"Tradeoffs",id:"tradeoffs",level:3},{value:"Thank you for reading!",id:"thank-you-for-reading",level:2}];function p(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A screenshot of Argo CD",src:n(6904).A+"",width:"1462",height:"871"})}),"\n",(0,i.jsx)(t.p,{children:"Argo CD is an awesome tool. It helps teams de-mystify the deployment process on\nKubernetes by providing a visual representation of the deployments in the\ncluster, and GitOps methodologies gives a consistent and understandable\nstructure to your configuration files."}),"\n",(0,i.jsx)(t.p,{children:"But what's the best way to scale when adding more teams? How can we make sure\nthat we're building our GitOps in a way that facilitates for self service and\nsecurity? That's what we'll discuss in this blog post."}),"\n",(0,i.jsx)(t.p,{children:"Kartverket has been using Argo CD and GitOps for several years, and we've built\nan architecture that solves our needs for scale and self-service. Here we'll\nshare our learnings and discuss why our teams are so happy with our Argo setup."}),"\n",(0,i.jsx)(t.h2,{id:"multi-tenancy-in-argo-cd",children:"Multi-tenancy in Argo CD"}),"\n",(0,i.jsx)(t.p,{children:"So you've deployed Argo CD on your multi-tenant cluster and given your teams\naccess to the user interface. Let's imagine we now have tens of teams and\nhundreds of applications in the Argo UI. When we start scaling out to more than\na handful of users we get into some issues with scale. Examples of these issues\ncan be:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"How do you organize your apps and projects?"}),"\n",(0,i.jsx)(t.li,{children:"How do you make sure no two teams accidentally (or maliciously) use the same\nnamespace?"}),"\n",(0,i.jsx)(t.li,{children:"How can we make sure teams clean up unused deployment resources?"}),"\n",(0,i.jsx)(t.li,{children:"How do you seamlessly deploy to multiple clusters?"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"As a platform team we often find ourselves thinking that everyone loves\ninfrastructure and Kubernetes as much as we do. This is not the case! Most\npeople have not had the joy of having their childhood ruined by installing\nLinux on their school laptops and configuring WLAN drivers using ndiswrapper.\nBelieve it or not, most people just want tools to get out of their way and let\nthem do their job, be that programming, testing or anything else. Not every team\nis going to be experts in Kubernetes and Argo. So should we expect all teams to\nknow what a deletion finalizer is? What about the intricacies of serverside\napply vs. clientside apply?"}),"\n",(0,i.jsx)(t.p,{children:"It's our responsibility as a platform team to make the user experience of\ndeploying to Kubernetes as user friendly as possible. After implementing an\narchitecture built with UX in mind we've had the joy of seeing people who are\nextremely skeptical of Kubernetes and the cloud be won over by how easy it is\nto get your workloads running on Kubernetes. This is thanks to the consistent\nuser experience and built-in best practices of the apps-repo architecture.\nBut we're getting ahead of ourselves, first we need to talk about a few\nabstractions that make this possible."}),"\n",(0,i.jsx)(t.h2,{id:"what-are-applicationsets",children:"What are ApplicationSets?"}),"\n",(0,i.jsxs)(t.p,{children:["In Argo CD there's an advanced feature that allows for automating\ncreation of Argo CD Applications called\n",(0,i.jsx)(t.a,{href:"https://argo-cd.readthedocs.io/en/stable/user-guide/application-set/",children:"ApplicationSets"}),".\nUsing an ApplicationSet we can essentially make a template that generates\nArgo CD applications based on files or folders in a Git repository, sort of like\na ",(0,i.jsx)(t.code,{children:"ReplicaSet"})," for ",(0,i.jsx)(t.code,{children:"Pods"}),'. Using ApplicationSets we can build in features and\nassumptions and provide the teams with a user experience that essentially boils\ndown to "add a file to a repo and it gets deployed to the cluster". The purest\nform of GitOps. No messing around with Argo CD applications and projects.']}),"\n",(0,i.jsxs)(t.p,{children:["A core Argo CD component called the ApplicationSet controller will detect any\n",(0,i.jsx)(t.code,{children:"ApplicationSet"})," resources deployed to the cluster and read them. After this, it\nwill periodically scan the a repo configured in the ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," resource\nand generate ",(0,i.jsx)(t.code,{children:"Application"})," resources, which in turn scan a repo for manifest\nfiles and sync them to the cluster. So in other words: ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," ->\n",(0,i.jsx)(t.code,{children:"Application"})," -> ",(0,i.jsx)(t.code,{children:"Deployments"})]}),"\n",(0,i.jsxs)(t.p,{children:["For this to work you need a Git repo containing manifest files. You could have\nthe teams put these manifest files into their source code repositories, but this\nis ",(0,i.jsx)(t.a,{href:"https://argo-cd.readthedocs.io/en/stable/user-guide/best_practices/#separating-config-vs-source-code-repositories",children:"not considered best\npractice"}),".\nUsually you would put your manifests into a separate repo so that changes to the\nmanifests don't conflict with changes in the source code. At Kartverket we call\nthis manifest repo an apps repo."]}),"\n",(0,i.jsx)(t.h2,{id:"introducing-apps-repositories",children:"Introducing apps repositories"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A cartoon character standing on a stage pointing to large letters saying &quot;Apps repo&quot;",src:n(31790).A+"",width:"1024",height:"1024"})}),"\n",(0,i.jsx)(t.p,{children:"The apps repo is where the product teams put their manifests. It has a consistent\nstructure and is designed to be read by an Argo CD ApplicationSet. It also has a\nlot of nifty features that enable self-service which we'll get back to."}),"\n",(0,i.jsx)(t.p,{children:"First, let's have a look at the structure of an apps repo."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"teamname-apps/\n  env/\n    clustername/\n      namespace/\n        example.yaml\n"})}),"\n",(0,i.jsx)(t.p,{children:"In the simplest of terms, this tree describes where to deploy a given manifest. By\nusing a directory tree it makes setting up an ApplicationSet for this repo trivial."}),"\n",(0,i.jsx)(t.p,{children:"Consider this example ApplicationSet:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: exampleteam-apps\n  namespace: argocd\nspec:\n  generators:\n    - git:\n        directories:\n          - path: env/*/*\n        repoURL: 'https://github.com/kartverket/exampleteam-apps.git'\n        revision: HEAD\n  goTemplate: true\n  goTemplateOptions:\n    - missingkey=error\n  template:\n    metadata:\n      name: '{{.path.basename}}'\n    spec:\n      destination:\n        namespace: '{{ index .path.segments 2 }}'\n        name: '{{ index .path.segments 1 }}'\n      project: exampleteam\n      source:\n        path: '{{.path.path}}'\n        repoURL: 'https://github.com/kartverket/exampleteam-apps.git'\n        targetRevision: HEAD\n      syncPolicy:\n        syncOptions:\n          - CreateNamespace=true\n        automated:\n          prune: true\n          allowEmpty: true\n          selfHeal: true\n"})}),"\n",(0,i.jsxs)(t.p,{children:["With this ApplicationSet any directory within ",(0,i.jsx)(t.code,{children:"env/*/*"})," will be picked up by\nthe ApplicationSet controller and a new Argo CD Application will be created\nbased on the template in the ",(0,i.jsx)(t.code,{children:"template"})," object. This enables a product team\nto create any number of applications for their products."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A chart showing apps repos synced into Kubernetes",src:n(99167).A+"",width:"771",height:"432"})}),"\n",(0,i.jsxs)(t.p,{children:["An example use for this is a product team wanting a namespace for each of\ntheir products. Instead of having to order a new namespace from the platform\nteam when they create a new product, they can simply create it themselves by\nadding a new directory with the same name as the namespace they want. A new\nKubernetes namespace will be automatically created thanks to the\n",(0,i.jsx)(t.code,{children:"CreateNamespace=true"})," sync option."]}),"\n",(0,i.jsxs)(t.p,{children:["Ephemeral namespaces, aka. preview namespaces, is another usecase. Say a team\nwants to review a change before merging it to ",(0,i.jsx)(t.code,{children:"main"}),". They could review the\nchange in the Pull Request, but this removes us from the end user's perspective\nand is not suitable for non-technical people. With a preview environment the\nteam will automatically create a new directory in the apps repo when a PR is\ncreated, and thus get a complete deployment with the change in question. This\nenables end-to-end testing in a browser, and also allows non-technical people\nto do QA before a change is merged. When it is merged another workflow can\nautomatically delete the directory, which cleans up and deletes the preview\nenvironment."]}),"\n",(0,i.jsxs)(t.p,{children:["Our convention is that namespaces are formatted with ",(0,i.jsx)(t.code,{children:"productname-branch"}),". This\nallows teams to have multiple deploys per product, and also multiple products\nper team. So when a new PR is created all a team needs to do to automate the\ncreation of a new directory using CI tools like GitHub actions to create a new\ncommit in the apps-repo. This also enables the flexibility to create it as a PR\nin the apps-repo, but for ephemeral namespaces, this is usually not necessary."]}),"\n",(0,i.jsx)(t.p,{children:"For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"footeam-apps/\n  env/\n    foo-cluster/\n      foo-main/\n        app.yaml\n      foo-feature-123/\n        app.yaml\n"})}),"\n",(0,i.jsx)(t.h2,{id:"automating-and-avoiding-duplication",children:"Automating and avoiding duplication"}),"\n",(0,i.jsx)(t.p,{children:'Depending on the complexity of the apps repo, the amount of products and branches\nand a subjective "ickyness" with duplicating files (can you spell DRY?), you have\nseveral options on how to automate creating new namespaces.'}),"\n",(0,i.jsxs)(t.p,{children:["Simple repos will probably be fine with directories containing simple yaml-files\nthat are synced to the cluster. Newer product teams especially appreciate the\nsimplicity of this approach. To optimize for this you may consider using a\n",(0,i.jsx)(t.code,{children:"template"})," directory at the base containing some example files that are copied\ninto the sub-directories. A pseudo-coded GitHub action that uses a\n",(0,i.jsx)(t.code,{children:"frontend.yaml"})," template from the templates directory could look like the\nfollowing:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'jobs:\n  build:\n    # Build a container image and push it\n\n  deploy:\n    strategy:\n      matrix:\n        env: [\'dev\', \'test\', \'prod\']\n    steps:\n      # .. Checkout repo & other setup ..\n\n      - name: Deploy to ${{ matrix.version }}\n        run: |\n          namespace="myapp-${{ github.ref_name }}"\n          path="./env/atkv3-${{ matrix.env }}/$namespace"\n          mkdir -p $path\n          cp -r templates/frontend.yaml $path/frontend.yaml\n          kubectl patch --local \\\n            -f $path/frontend.yaml \\\n            -p \'{"spec":{"image":"${{needs.build.outputs.container_image_tag}}"}}\' \\\n            -o yaml\n          git config --global user.email "github-actions@github.com"\n          git config --global user.name "GitHub Actions"\n          git commit -am "Deploy ${{ matrix.env }} version ${{ github.ref_name }}"\n          git push\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This works for most simple apps. Our experience, however, is that as a team\nmatures and gets more experienced with Kubernetes and Argo CD, they add more\ncomplexity and want more control. At this point most teams will migrate to using\n",(0,i.jsx)(t.a,{href:"https://jsonnet.org",children:"jsonnet"})," to enable referencing and extending a reusable\nlibrary shared between multiple components. SKIP also provides some common\nmanifests via ",(0,i.jsx)(t.a,{href:"https://github.com/kartverket/argokit",children:"ArgoKit"}),", a jsonnet\nlibrary."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://kustomize.io",children:"Kustomize"})," is also a common choice, widely used by SKIP\nfor our own infrastructure, but not really widespread with other teams."]}),"\n",(0,i.jsxs)(t.p,{children:["Despite Argo supporting ",(0,i.jsx)(t.a,{href:"https://helm.sh/",children:"Helm"})," we mostly avoid using it to\ncreate reusable templates due to the complexity of templating YAML. Jsonnet is\nsuperior in this regard."]}),"\n",(0,i.jsxs)("blockquote",{className:"twitter-tweet",children:[(0,i.jsxs)("p",{lang:"en",dir:"ltr",children:["Fixing indentation errors in YAML templates in a Helm chart ",(0,i.jsx)("a",{href:"https://t.co/Dv2JUkCdiM",children:"pic.twitter.com/Dv2JUkCdiM"})]}),"\u2014 memenetes (@memenetes) ",(0,i.jsx)("a",{href:"https://twitter.com/memenetes/status/1600898397279502336?ref_src=twsrc%5Etfw",children:"December 8, 2022"})]}),"\n",(0,i.jsx)(t.h2,{id:"security-considerations",children:"Security considerations"}),"\n",(0,i.jsx)(t.p,{children:'You may be wondering: "This seems great and all, but what about the security\nimplications of allowing teams to create and edit namespaces in a multi-tenant\ncluster? That seems really dangerous!".'}),"\n",(0,i.jsx)(t.p,{children:"First of all, I love you for thinking about security. We need more people like\nyou. Second, Argo CD has some great features we can leverage to make this work\nwithout removing the self-service nature of the apps repo architecture."}),"\n",(0,i.jsx)(t.h3,{id:"prefixes",children:"Prefixes"}),"\n",(0,i.jsx)(t.p,{children:"In order to make this work we need to give each team a set of prefixes. A\nprefix will usually be the name of a product that a product team has\nresponsibility for maintaining. The only important part is that it is unique\nand that no other teams have been allocated the same prefix. At Kartverket\nthis is done by the platform team as part of the team onboarding process."}),"\n",(0,i.jsxs)(t.p,{children:["The prefix is used as part of all namespaces that are created by the teams. In\nthe example namespace ",(0,i.jsx)(t.code,{children:"product-feature-123"}),", ",(0,i.jsx)(t.code,{children:"product"})," is the prefix. By giving\neach team a set of prefixes it helps them separate products into easily\nidentifiable namespaces and it ensures that a product team does not accidentally\nuse another team's namespace."]}),"\n",(0,i.jsx)(t.p,{children:"Since each product team has an apps repo with the ability to name their\ndirectories as they wish, how can we enforce this? This is where Argo CD's\nProjects come into play."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://argo-cd.readthedocs.io/en/stable/user-guide/projects/",children:"Argo CD Projects"}),"\nprovide a logical grouping of applications, which is useful when Argo CD is used\nby multiple teams. It also contains a field that allows allowlisting which\nclusters and namespaces are usable by a project."]}),"\n",(0,i.jsxs)(t.p,{children:["Add the following to a Project to only allow this project to create and sync to\nnamespaces prefixed with ",(0,i.jsx)(t.code,{children:"myprefix-"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"metadata:\n  name: exampleteam\nspec:\n  destinations:\n  - namespace: 'myprefix-*'\n    server: '*'\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If you scroll back up to the ApplicationSet example above, you will see that it\nonly creates applications with the project ",(0,i.jsx)(t.code,{children:"exampleteam"}),". This will automatically\nwire any applications created to the destination rules we've defined in this\nproject and therefore deny any attempts by a team to use prefixes that they have\nnot been allocated."]}),"\n",(0,i.jsx)(t.p,{children:"The crucial part here is that ApplicationSets and Projects are provisioned by the\nplatform team, and therefore build in these security features. These resources\nmust not be accessible to the teams, or an attacker can simply add exclusions."}),"\n",(0,i.jsx)(t.h3,{id:"namespace-resources",children:"Namespace resources"}),"\n",(0,i.jsx)(t.p,{children:"Another way this could be abused is if a team is able to create Namespace\nresources in their apps repository. This should be denied using Argo and/or\ncluster policies."}),"\n",(0,i.jsxs)(t.p,{children:['If a team is able to create namespace resources (or other cluster scoped\nresources) in their namespace an attacker can use this to break their namespace\n"encapsulation". Imagine for example if one could use their apps repo to sync\na namespace resource named ',(0,i.jsx)(t.code,{children:"kube-system"})," into their ",(0,i.jsx)(t.code,{children:"env/foo-cluster/foo-main"}),"\ndirectory. Argo CD would allow this, as the manifests are read into an Argo CD\napplication. Then the attacker could delete the namespace and take down the\ncluster."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://www.youtube.com/watch?v=8Zwftqf8g8w",children:(0,i.jsx)(t.img,{alt:"A slide from KubeCon Europe 2024 showing why it&#39;s a bad idea to let product teams create namespaces",src:n(36884).A+"",width:"2560",height:"1440"})})}),"\n",(0,i.jsxs)(t.p,{children:["It's useful in this multi-tenancy scenario to think of namespaces as resources\nowned by the platform team and namespace-scoped resources as owned by the\nproduct teams. This is considered a best practice, and was reiterated at ",(0,i.jsx)(t.a,{href:"https://www.youtube.com/watch?v=8Zwftqf8g8w",children:"KubeCon\nEurope 2024 by Marco De Benedictis"}),".\nAllowing product teams to edit namespaces can open up a ton of attack vectors,\nlike disabling ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/security/pod-security-admission",children:"Pod Security\nAdmission"}),"\ncontrollers, allowing an attacker to create privileged containers which can\ncompromise the host node."]}),"\n",(0,i.jsx)(t.p,{children:"Friends don't let friends edit namespaces!"}),"\n",(0,i.jsx)(t.h2,{id:"self-service-customization",children:"Self service customization"}),"\n",(0,i.jsxs)(t.p,{children:["So we set up an ApplicationSet that configures best practices and secure\ndefaults for product teams! Great! But now that team with experienced cloud\nengineers really wants to customize their Argo configuration. Maybe they want to\nconfigure that one app has ",(0,i.jsx)(t.a,{href:"https://argo-cd.readthedocs.io/en/stable/user-guide/auto_sync/",children:"auto\nsync"})," on, but\nanother app has it turned off. Maybe they want to disable self-healing for a\nshort period to manually edit in the cluster. In any case, how can we let teams\nchange this configuration self-service when applications are provisioned by the\n",(0,i.jsx)(t.code,{children:"ApplicationSet"})," resource?"]}),"\n",(0,i.jsxs)(t.p,{children:["We could let the teams edit the ApplicationSet. In our case this would mean\nthe teams need to learn about the ApplicationSet abstraction, gotemplate and\nSKIP's internal GitOps repo structure. This is overkill when a team usually just\nwants to flip a flag between true or false for a directory. There could also be\nsecurity implications with allowing teams to edit ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," resources\nthat could break encapsulation, which we want to avoid."]}),"\n",(0,i.jsx)(t.p,{children:"Another option would be to contact the platform team and tell us to change some\nconfig for them. This is not in line with our thinking, as we want the teams to\nbe able to work autonomously for most operations like this. It would also mean\nwe were given a lot of menial tasks which would mean we have less time to do\nother more meaningful things or become a bottleneck for the teams."}),"\n",(0,i.jsxs)(t.p,{children:["A third option is setting the ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," sync policy to ",(0,i.jsx)(t.code,{children:"create-only"}),".\nThis would confifure the ApplicationSet controller to create Application\nresources, but prevent any further modification, such as deletion, or\nmodification of Application fields. This would allow a team to edit the\napplication in the UI after creation, for example disabling auto sync. This last\noption is user friendly, but in violation of GitOps principles where config\nlives in git and not in a database. If you run Argo stateless like we do this\nwould also mean the changes disappear when the pod restarts."]}),"\n",(0,i.jsxs)(t.p,{children:["Because none of these options seemed to be the best, we created a better\nsolution. By using a combination of generators and the new ",(0,i.jsx)(t.a,{href:"https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Template/#template-patch",children:"template patch"}),"\nfeature in Argo CD 2.8 we can look through every directory in the apps repo\nfor a configuration file called ",(0,i.jsx)(t.code,{children:"config.json"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's look at an example ",(0,i.jsx)(t.code,{children:"config.json"})," file. This example file is commited in\nthe apps repo to the ",(0,i.jsx)(t.code,{children:"env/foo-cluster/foo-main"})," directory."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'{\n  "tool": "kustomize",\n  "autoSync": false\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This file is not required, but if this file is found the values configured there\noverrides a set of default values in the ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," template. These flags\nare then used to determine how the resulting ",(0,i.jsx)(t.code,{children:"Application"})," will behave. This\nmeans the team is able to change the values they care about per directory of\ntheir apps repo"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"footeam-apps/\n  env/\n    foo-cluster/\n      foo-main/\n        config.json\n        app.yaml\n      foo-feature-123/\n        config.json\n        app.yaml\n      foo-feature-with-default-config/\n        app.yaml\n"})}),"\n",(0,i.jsx)(t.p,{children:"Additionaly, since the platform team is in control of the template we can\neliminate the ability to maliciously change the template by parsing the inputs\nin a secure way."}),"\n",(0,i.jsx)(t.h3,{id:"example-applicationset",children:"Example ApplicationSet"}),"\n",(0,i.jsxs)(t.p,{children:["Let's look at how we can write an ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," that allows us to use\n",(0,i.jsx)(t.code,{children:"config.json"})," files."]}),"\n",(0,i.jsxs)(t.p,{children:["First, we need to configure the ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," to look through all directories,\nand at the same time use a ",(0,i.jsx)(t.code,{children:"config.json"})," file if it is found. This is perhaps\nthe least intuitive part of this new ",(0,i.jsx)(t.code,{children:"ApplicationSet"}),", so let's walk through it\nstep by step."]}),"\n",(0,i.jsxs)(t.p,{children:["First we create a merge generator, which will merge two generators. The key\nthing here is that it only merges if the ",(0,i.jsx)(t.code,{children:"key"})," matches in both generators, so\nthis allows us to first find all directories (the default), then directories\nthat contain ",(0,i.jsx)(t.code,{children:"config.json"})," files (the override)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:" generators:\n  - merge:\n      generators:\n      - # default\n      - # override\n      mergeKeys:\n      - key\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now we're going to add the generator from before into the default. The only\ndifference is we're doing this using a matrix generator. Doing this combines the\nparameters generated by the two child generators, which gives us the values from\nthe git generator like before, but also a set of default values we can use in\nour template later if the ",(0,i.jsx)(t.code,{children:"config.json"})," file is not provided."]}),"\n",(0,i.jsxs)(t.p,{children:["We're also using a value from the git generator to assign a ",(0,i.jsx)(t.code,{children:"key"})," that will\nuniquely identify this directory for the merge generator later."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:" generators:\n  - merge:\n      generators:\n      - matrix:\n          generators:\n          - git:\n              directories:\n                - path: env/*/*\n              repoURL: 'https://github.com/kartverket/exampleteam-apps.git'\n              revision: HEAD\n          - list:\n              elements:\n              - allowEmpty: false\n                autoSync: true\n                key: '{{ .path.basenameNormalized}}'\n                prune: true\n                selfHeal: true\n                tool: directory\n      - # override\n      mergeKeys:\n      - key\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now we use a variant of the git generator to find all ",(0,i.jsx)(t.code,{children:"config.json"})," files in\nthe same repo and extract the values from it. Again we're using the key field\nto uniquely identify this directory so that it will be merged with the correct\ndirectory in the merge generator."]}),"\n",(0,i.jsx)(t.p,{children:"We're repeating the default values here as well, since not all fields are\nrequired and we don't want them to be overwritten as null in the resulting\nmerge."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:" generators:\n  - merge:\n      generators:\n      - matrix:\n          generators:\n          - git:\n              directories:\n                - path: env/*/*\n              repoURL: 'https://github.com/kartverket/exampleteam-apps.git'\n              revision: HEAD\n          - list:\n              elements:\n              - allowEmpty: false\n                autoSync: true\n                key: '{{ .path.basenameNormalized}}'\n                prune: true\n                selfHeal: true\n                tool: directory\n      - matrix:\n          generators:\n          - git:\n              files:\n              - path: env/*/*/config.json\n              repoURL: 'https://github.com/kartverket/exampleteam-apps.git'\n              revision: HEAD\n          - list:\n              elements:\n              - allowEmpty: false\n                autoSync: true\n                key: '{{ .path.basenameNormalized}}'\n                prune: true\n                selfHeal: true\n                tool: directory\n      mergeKeys:\n      - key\n"})}),"\n",(0,i.jsxs)(t.p,{children:["That's it for the generator! Now we can use these variables in the\n",(0,i.jsx)(t.code,{children:"templatePatch"})," field (and other fields). In this case we want to set syncPolicy\noptions, so we need to use the ",(0,i.jsx)(t.code,{children:"templatePatch"}),", as gotemplates don't work for\nobjects."]}),"\n",(0,i.jsxs)(t.p,{children:["We're also adding a special case where for ",(0,i.jsx)(t.code,{children:"directory"})," sources (the default) we\nexclude ",(0,i.jsx)(t.code,{children:"config.json"})," files, as we don't want to sync the config file with Argo.\nThis allows us to extend it later to add options for other tools like Kustomize\nor Helm."]}),"\n",(0,i.jsx)(t.p,{children:"Keep in mind that we don't want users to inject maliciously formed patches, so\nwe cast booleans to booleans."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'  templatePatch: |\n    spec:\n      source:\n        directory:\n      {{- if eq .tool "directory" }}\n          exclude: config.json\n      {{- end }}\n    {{- if .autoSync }}\n      syncPolicy:\n        automated:\n          allowEmpty: {{ .allowEmpty | toJson }}\n          prune: {{ .prune | toJson }}\n          selfHeal: {{ .selfHeal | toJson }}\n    {{- end }}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"complete-applicationset",children:"Complete ApplicationSet"}),"\n",(0,i.jsxs)(t.p,{children:["Here is a complete ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," containing all the features we've discussed\nso far."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: exampleteam-apps\n  namespace: argocd\nspec:\n  generators:\n  - merge:\n      generators:\n      - matrix:\n          generators:\n          - git:\n              directories:\n                - path: env/*/*\n              repoURL: 'https://github.com/kartverket/exampleteam-apps.git'\n              revision: HEAD\n          - list:\n              elements:\n              - allowEmpty: false\n                autoSync: true\n                key: '{{ .path.basenameNormalized}}'\n                prune: true\n                selfHeal: true\n                tool: directory\n      - matrix:\n          generators:\n          - git:\n              files:\n              - path: env/*/*/config.json\n              repoURL: https://github.com/kartverket/exampleteam-apps.git\n              revision: HEAD\n          - list:\n              elements:\n              - allowEmpty: false\n                autoSync: true\n                key: '{{ .path.basenameNormalized}}'\n                prune: true\n                selfHeal: true\n                tool: directory\n      mergeKeys:\n      - key\n  goTemplate: true\n  goTemplateOptions:\n  - missingkey=error\n  template:\n    metadata:\n      name: '{{.path.basenameNormalized}}'\n    spec:\n      destination:\n        namespace: '{{ index .path.segments 2 }}'\n        name: '{{ index .path.segments 1 }}'\n      project: exampleteam\n      source:\n        path: '{{.path.path}}'\n        repoURL: 'https://github.com/kartverket/exampleteam-apps.git'\n        targetRevision: HEAD\n      syncPolicy:\n        managedNamespaceMetadata:\n          labels:\n            app.kubernetes.io/managed-by: argocd\n            pod-security.kubernetes.io/audit: restricted\n            team: exampleteam\n        syncOptions:\n        - CreateNamespace=true\n        - ServerSideApply=true\n        - PrunePropagationPolicy=background\n  templatePatch: |\n    spec:\n      source:\n        directory:\n      {{- if eq .tool \"directory\" }}\n          exclude: config.json\n      {{- end }}\n    {{- if .autoSync }}\n      syncPolicy:\n        automated:\n          allowEmpty: {{ .allowEmpty | toJson }}\n          prune: {{ .prune | toJson }}\n          selfHeal: {{ .selfHeal | toJson }}\n    {{- end }}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"results",children:"Results"}),"\n",(0,i.jsx)(t.p,{children:"With Argo CD and the apps repo architecture, we've seen some real improvements\nin our deploy system. Teams find it to be incredibly intuitive to just update a\nfile in Git and have it be instantly reflected in Argo CD and Kubernetes,\nespecially when combined with Argo CD auto-sync."}),"\n",(0,i.jsx)(t.p,{children:"Onboarding new teams is quick and easy, since just putting files into a Git repo\nis something most developers are already familiar with. We just show them the\nstructure of the apps repo and they're good to go. A team can go from not having\nany experience with Kubernetes to deploying their first application in a matter\nof minutes."}),"\n",(0,i.jsxs)(t.p,{children:["Migrating from one cluster to another is also a breeze. Just move manifests from\none directory under ",(0,i.jsx)(t.code,{children:"env"})," to another, and the ApplicationSet will take care of\nthe rest. This is especially useful for teams that want to start developing with\nnew cloud native principles on-premises, modernizing the application and\neventually moving to the cloud."]}),"\n",(0,i.jsxs)(t.p,{children:["I feel the key part of this architecture is the ",(0,i.jsx)(t.code,{children:"config.json"})," file. It allows\na degree of customization that is not possible with the default ",(0,i.jsx)(t.code,{children:"ApplicationSet"}),"\ntemplate and was to us the last missing piece. It allows teams to change\nconfiguration without needing to know about the ",(0,i.jsx)(t.code,{children:"ApplicationSet"})," abstraction,\nand it allows the platform team to enforce security and best practices."]}),"\n",(0,i.jsx)(t.h3,{id:"tradeoffs",children:"Tradeoffs"}),"\n",(0,i.jsx)(t.p,{children:"But of course, there are some drawbacks. Like always, it's tradeoffs all the\nway down."}),"\n",(0,i.jsx)(t.p,{children:"Since a product team uses an apps repo to organize their apps, moving apps\nfrom one team to another will require migrating files from one repo to another.\nThis will require some manual work to prevent Argo deleting the entire namespace\nwhen the directory is removed from the old repo. Usually this is not a big\nissue, and moving projects between teams happens very rarely, but it's something\nto keep in mind."}),"\n",(0,i.jsx)(t.p,{children:"There is also a risk that a team could accidentally delete a namespace by\nremoving a directory in the apps repo. We have mitigated this by disabling\nauto-sync for most mission critical applications in production."}),"\n",(0,i.jsxs)(t.p,{children:["And finally, projects that don't have clear ownership or shared ownership can\nbe tricky to place into a repo. You could make an apps repo for a \"pseudo-team\"\nconsisting of the teams that need access, but generally we find that it's better\nthat all products have a clear singular main owner. This also prevents\n",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Diffusion_of_responsibility",children:"diffusion of responsibility"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"thank-you-for-reading",children:"Thank you for reading!"}),"\n",(0,i.jsxs)(t.p,{children:["We hope you found this article helpful and informative. Getting into\n",(0,i.jsx)(t.code,{children:"ApplicationSets"})," can be a bit tricky, so we hope we managed to convey the most\nimportant parts in a clear and understandable way. Thanks for reading!"]}),"\n",(0,i.jsxs)(t.p,{children:["We recently created a Mastodon account ",(0,i.jsx)(t.a,{href:"https://mastodon.social/@kv_plattform",children:"@kv_plattform"}),"!\nIf you want to contact us or discuss this article, feel free to reach out to us\nthere."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},31790:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/apps-repo-announcment-df699d967970c45b70163fe4b8643321.jpeg"},6904:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/argo-3-d24ad69c47a9a4b6d82c4434370b06e6.png"},99167:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/argo-apps-repos-a929069a4546fefc8eecf35b5e3ab3a0.png"},36884:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/no-edit-namespaces-4fb442adfde71a267cbbb80031841c28.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(96540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}},80482:e=>{e.exports=JSON.parse('{"permalink":"/blog/introducing-apps-repositories","source":"@site/blog/2024-04-22-apps-repositories.md","title":"Scaling with Argo CD: Introducing the Apps Repo Architecture","description":"What\'s the best way to scale when adding more teams to Argo CD? How can we make sure that we\'re building our GitOps in a way that facilitates self service and security? Kartverket shares our experiences and introduces the apps repo architecture\\n","date":"2024-04-22T00:00:00.000Z","tags":[{"inline":true,"label":"kubernetes","permalink":"/blog/tags/kubernetes"},{"inline":true,"label":"argo-cd","permalink":"/blog/tags/argo-cd"},{"inline":true,"label":"gitops","permalink":"/blog/tags/gitops"}],"readingTime":19.165,"hasTruncateMarker":true,"authors":[{"name":"Eline Henriksen","title":"Product Owner and Platform Developer","url":"https://eliine.dev","imageURL":"https://github.com/eliihen.png","key":"elinehenriksen","page":null}],"frontMatter":{"title":"Scaling with Argo CD: Introducing the Apps Repo Architecture","description":"What\'s the best way to scale when adding more teams to Argo CD? How can we make sure that we\'re building our GitOps in a way that facilitates self service and security? Kartverket shares our experiences and introduces the apps repo architecture\\n","slug":"introducing-apps-repositories","authors":["elinehenriksen"],"tags":["kubernetes","argo-cd","gitops"],"image":"/img/apps-repo-announcment.jpeg","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"20 teams on SKIP: What we\'ve learned along the way","permalink":"/blog/20-teams-on-skip"},"nextItem":{"title":"Crisis Management Exercises","permalink":"/blog/crisis-management-exercises"}}')}}]);